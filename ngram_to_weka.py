# docs

# python ngram_to_weka.py trec07p Data/NGramTest/lower_chars 60001 60003 Models lower_chars out.txt 3 5


import argparse
import subprocess


JAVA_CP  = 'berkeleylm-1.1.6/src'
LM_CLASS = 'edu.berkeley.nlp.lm.io.ComputeLogProbabilityOfTextStream'
JAVA_CMD = 'java -ea -mx1000m -server -cp ' + JAVA_CP + ' ' + LM_CLASS


def run_bash_cmd(command):
    """Executes a bash command and returns its output as a string."""
    p = subprocess.Popen(command.split(), \
                         stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = p.communicate()
    if len(out.strip()) == 0:
        print "Output failed on command:"
        print command
        print "Error was: " + err
        exit(0)
    return out


def extract_probability(model_output):
    """Returns the probability extracted from the Berkley LM output text."""
    return model_output.strip().split()[-1]


def join_outputs(outputs, new_outputs):
    """Adds all features of the new_outputs to the existing outputs list."""
    if len(outputs) == 0:
        return new_outputs
    else:
        assert(len(outputs) == len(new_outputs))
        for i in range(len(outputs)):
            for feature in new_outputs[i][2]:
                outputs[i][2].append(feature)
        return outputs


def ngram_to_weka(args, model_type = None):
    """
    Evaluates each input message on both the spam and ham N-Gram models for
    each value of N provided. Returns a list of tuples, where each tuple
    contains the message number, the message label (spam or ham), and a list
    of inner tuples for each N-Gram. Each inner tuple contains the value of N
    for that particular model, followed by the ham and spam log probabilities,
    respectively.
    e.g.
    [(60001, 'ham', ['-2341.23', '-3245.32', '-3241.33', '-3421.32']),
     (60002, 'ham', ['-5241.64', '-2512.42', '-1325.78', '-3513.23'])]
    """
    if model_type is None:
        outputs = []
        for model_type in args.model_type:
            outputs = join_outputs(outputs, ngram_to_weka(args, model_type))
        return outputs
    label_file = open(args.data_dir + 'full/index', 'r')
    labels = label_file.readlines()
    label_file.close()
    labels = [label.split()[0] for label in labels]
    outputs = []
    model_bin_ham = model_type + '_ham.binary'
    model_bin_spam = model_type + '_spam.binary'
    for num in range(args.range_start, args.range_end+1):
        label = labels[num-1]
        msg_file = args.in_dir + 'message_' + str(num)
        probs = []
        for n_val in args.N_vals:
            n_prefix = 'N_' + str(n_val) + '_'
            model_bin_ham_N = args.model_dir + n_prefix + model_bin_ham
            model_bin_spam_N = args.model_dir + n_prefix + model_bin_spam
            ham_output = run_bash_cmd(JAVA_CMD + ' ' + model_bin_ham_N + ' ' + msg_file)
            ham_prob = extract_probability(ham_output)
            spam_output = run_bash_cmd(JAVA_CMD + ' ' + model_bin_spam_N + ' ' + msg_file)
            spam_prob = extract_probability(spam_output)
            probs += [ham_prob, spam_prob]
        outputs.append((num, label, probs))
    return outputs


def add_feature(outputs, values):
    """Adds the given list of features at the end of each output."""
    # TODO - untested
    assert(len(outputs) == len(values))
    for val in values:
        outputs[2].append(val)


def write_arff_file(args, outputs):
    """
    Writes the .arff weka file using the given output values. The outputs
    should be formatted the same way as the return format of the
    "ngram_to_weka" function. Additional values may be inserted as tuples
    using the "add_feature" function. Added features should not be regular
    strings, and if they are, they must be *in quotes* and *escaped*.
    """
    outfile = open(args.outfile, 'w')
    outfile.write("% ARFF generated by Python N-Gram to Weka script.\n\n")
    outfile.write("@RELATION ngram\n\n")
    for model_type in args.model_type:
        for N in args.N_vals:
            for msg_class in ['ham', 'spam']:
                attribute = 'N_' + str(N) + '_' + model_type + '_' + msg_class
                outfile.write("@ATTRIBUTE " + attribute + " NUMERIC\n")
    outfile.write("@ATTRIBUTE spam_or_ham_class {spam,ham}\n\n")
    outfile.write("@DATA\n")
    for output in outputs:
        msg_class = output[1]
        features = output[2]
        for feature in features:
            outfile.write(feature + ' ')
        outfile.write(msg_class + '\n')
    outfile.close()


# Process args and run the evaluation code.
if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('data_dir', \
                        help="Trec 2007 corpus directory.")
    parser.add_argument('in_dir', \
                        help="Directory of the input N-Gram files.")
    parser.add_argument('range_start', type=int, \
                        help="First file in the data batch.")
    parser.add_argument('range_end', type=int, \
                        help="Last file in the data batch.")
    parser.add_argument('model_dir', \
                        help="Directory of the binary model files.")
    parser.add_argument('model_type', \
                        help="Which model to use (e.g. chars_upper).")
    parser.add_argument('outfile', \
                        help="Output .arff file or N-Gram file/directory.")
    parser.add_argument('N_vals', type=int, nargs='+',
                        help='A list of N values (N-Gram model types).')
    args = parser.parse_args()
    if not args.data_dir.endswith('/'):
        args.data_dir += '/'
    if not args.in_dir.endswith('/'):
        args.in_dir += '/'
    if not args.model_dir.endswith('/'):
        args.model_dir += '/'
    if args.model_type == 'all':
        args.model_type = 'lower_chars/lower_words/upper_chars/upper_words'
    args.model_type = args.model_type.split('/')
    outputs = ngram_to_weka(args)
    #print "Output is of the following form:"
    #print "   msg #, class, (for each model type: (for each N: (ham prob, spam prob)))"
    #for output in outputs:
    #    print output
    write_arff_file(args, outputs)
